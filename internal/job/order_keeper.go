package job

import (
	"context"
	"fmt"
	"math/big"
	"strings"
	"time"

	"github.com/fachebot/evm-grid-bot/internal/ent"
	"github.com/fachebot/evm-grid-bot/internal/ent/grid"
	"github.com/fachebot/evm-grid-bot/internal/ent/order"
	"github.com/fachebot/evm-grid-bot/internal/logger"
	"github.com/fachebot/evm-grid-bot/internal/model"
	"github.com/fachebot/evm-grid-bot/internal/strategy"
	"github.com/fachebot/evm-grid-bot/internal/svc"
	"github.com/fachebot/evm-grid-bot/internal/utils"
	"github.com/fachebot/evm-grid-bot/internal/utils/evm"
	"github.com/fachebot/evm-grid-bot/internal/utils/format"

	"github.com/ethereum/go-ethereum/common"
	"github.com/shopspring/decimal"
)

type OrderKeeper struct {
	ctx        context.Context
	cancel     context.CancelFunc
	stopChan   chan struct{}
	svcCtx     *svc.ServiceContext
	timeoutTxs map[string]struct{}
}

func NewOrderKeeper(svcCtx *svc.ServiceContext) *OrderKeeper {
	ctx, cancel := context.WithCancel(context.Background())
	return &OrderKeeper{
		ctx:        ctx,
		cancel:     cancel,
		svcCtx:     svcCtx,
		timeoutTxs: map[string]struct{}{},
	}
}

func (keeper *OrderKeeper) Stop() {
	if keeper.stopChan == nil {
		return
	}

	logger.Infof("[OrderKeeper] ÂáÜÂ§áÂÅúÊ≠¢ÊúçÂä°")

	keeper.cancel()

	<-keeper.stopChan
	close(keeper.stopChan)
	keeper.stopChan = nil

	logger.Infof("[OrderKeeper] ÊúçÂä°Â∑≤ÁªèÂÅúÊ≠¢")
}

func (keeper *OrderKeeper) Start() {
	if keeper.stopChan != nil {
		return
	}

	keeper.stopChan = make(chan struct{})
	logger.Infof("[OrderKeeper] ÂºÄÂßãËøêË°åÊúçÂä°")
	go keeper.run()
}

func (keeper *OrderKeeper) run() {
	timer := time.NewTimer(0)
	defer timer.Stop()

	for {
		select {
		case <-timer.C:
			keeper.handlePolling()
			duration := time.Millisecond * 1000
			timer.Reset(duration)
		case <-keeper.ctx.Done():
			keeper.stopChan <- struct{}{}
			return

		}
	}
}

func (keeper *OrderKeeper) sendNotification(ord *ent.Order, text string, force bool) {
	w, err := keeper.svcCtx.WalletModel.FindByAccount(keeper.ctx, ord.Account)
	if err != nil {
		logger.Errorf("[OrderKeeper] Êü•ËØ¢Èí±ÂåÖ‰ø°ÊÅØÂ§±Ë¥•, account: %s, %v", ord.Account, err)
		return
	}

	if ord.StrategyId != "" {
		s, err := keeper.svcCtx.StrategyModel.FindByUserIdGUID(keeper.ctx, w.UserId, ord.StrategyId)
		if err != nil {
			logger.Errorf("[OrderKeeper] Êü•ËØ¢Á≠ñÁï•‰ø°ÊÅØÂ§±Ë¥•, userId: %d, strategyId: %s, %v", w.UserId, ord.StrategyId, err)
			return
		}

		if !force && !s.EnablePushNotification {
			return
		}
	}

	if w.UserId == 0 {
		logger.Warnf("[OrderKeeper] Áî®Êà∑Êú™ÁªëÂÆöTelegramË¥¶Âè∑, Êó†Ê≥ïÂèëÈÄÅÈÄöÁü•")
		return
	}

	_, err = utils.SendMessage(keeper.svcCtx.BotApi, w.UserId, text)
	if err != nil {
		logger.Warnf("[OrderKeeper] ÂèëÈÄÅÁîµÊä•ÈÄöÁü•Â§±Ë¥•, userId: %d, text: %s, %v", w.UserId, text, err)
		return
	}
}

func (keeper *OrderKeeper) handleRetryExit(ord *ent.Order) {
	// Êü•ËØ¢Á≠ñÁï•
	record, err := keeper.svcCtx.StrategyModel.FindByGUID(keeper.ctx, ord.StrategyId)
	if err != nil {
		logger.Errorf("[OrderKeeper] Êü•ËØ¢Á≠ñÁï•‰ø°ÊÅØÂ§±Ë¥•, account: %s, strategy: %s, %v", ord.Account, ord.StrategyId, err)
		return
	}

	keeper.sendNotification(ord, fmt.Sprintf("‚ôªÔ∏è Ê≠£Âú®Â∞ùËØïÈáçÊñ∞Ê∏Ö‰ªì *%s* ‰ª£Â∏ÅÂ§±Ë¥•", ord.Symbol), true)

	// ÂçñÂá∫‰ª£Â∏Å
	orderArgs, err := strategy.SellToken(keeper.ctx, keeper.svcCtx, record, "ÈáçÊñ∞Ê∏Ö‰ªì", &ord.InAmount, nil, true)
	if err != nil {
		logger.Errorf("[OrderKeeper] Â∞ùËØïÈáçÊñ∞Ê∏Ö‰ªìÂ§±Ë¥•, strategy: %s, token: %s, %v", ord.StrategyId, ord.Symbol, err)
		keeper.sendNotification(ord, fmt.Sprintf("‚ùå Â∞ùËØïÈáçÊñ∞Ê∏Ö‰ªì *%s* ‰ª£Â∏ÅÂ§±Ë¥•ÔºåËØ∑ÊâãÂä®Ê∏Ö‰ªì", ord.Symbol), true)
		return
	}
	orderArgs.GridBuyCost = ord.GridBuyCost

	// ‰øùÂ≠òËÆ¢ÂçïËÆ∞ÂΩï
	err = utils.Tx(keeper.ctx, keeper.svcCtx.DbClient, func(tx *ent.Tx) error {
		_, err = model.NewOrderModel(tx.Order).Save(keeper.ctx, orderArgs)
		return err
	})
	if err != nil {
		logger.Errorf("[OrderKeeper] ‰øùÂ≠òËÆ¢ÂçïËÆ∞ÂΩïÂ§±Ë¥•, order: %+v, %v", orderArgs, err)
	}
}

func (keeper *OrderKeeper) handleCloseOrder(ord *ent.Order, tokenBalanceChanges map[common.Address]*big.Int) {
	tokenMeta, err := keeper.svcCtx.TokenMetaCache.GetTokenMeta(keeper.ctx, ord.Token)
	if err != nil {
		logger.Errorf("[OrderKeeper] Êü•ËØ¢‰ª£Â∏ÅÂÖÉÊï∞ÊçÆÂ§±Ë¥•, token: %s, %v", ord.Token, err)
		return
	}

	// ËÆ°ÁÆóÊúÄÁªà‰ª∑Ê†º
	cost := decimal.Zero
	var finalPrice, outAmount decimal.Decimal
	stablecoinCA := common.HexToAddress(keeper.svcCtx.Config.Chain.StablecoinCA)

	switch ord.Type {
	case order.TypeBuy:
		change := decimal.Zero
		v, ok := tokenBalanceChanges[common.HexToAddress(ord.Token)]
		if ok {
			change = evm.ParseUnits(v, tokenMeta.Decimals)
		}

		if ok && !change.Equal(decimal.Zero) {
			finalPrice = ord.InAmount.Div(change)
		}
		outAmount = change
	case order.TypeSell:
		change := decimal.Zero
		v, ok := tokenBalanceChanges[stablecoinCA]
		if ok {
			change = evm.ParseUnits(v, keeper.svcCtx.Config.Chain.StablecoinDecimals)
		}

		if ok && !ord.InAmount.Equal(decimal.Zero) {
			finalPrice = change.Div(ord.InAmount)
		}
		outAmount = change

		if ord.GridBuyCost != nil {
			cost = *ord.GridBuyCost
		} else if ord.GridId != nil {
			g, err := keeper.svcCtx.GridModel.FindByGuid(keeper.ctx, *ord.GridId)
			if err == nil {
				cost = g.Amount
			} else {
				logger.Errorf("[OrderKeeper] Êü•ËØ¢ÁΩëÊ†º‰ø°ÊÅØÂ§±Ë¥•, guid: %s, %v", *ord.GridId, err)
			}
		}
	}

	// Ëé∑ÂèñÁ≠ñÁï•‰ø°ÊÅØ
	s, err := keeper.svcCtx.StrategyModel.FindByGUID(keeper.ctx, ord.StrategyId)
	if err != nil {
		logger.Errorf("[OrderKeeper] Êü•ËØ¢Á≠ñÁï•‰ø°ÊÅØÂ§±Ë¥•, guid: %s, %v", ord.StrategyId, err)
	}

	// Êü•ËØ¢Á®≥ÂÆöÂ∏Å‰ΩôÈ¢ù
	bal, err := evm.GetTokenBalance(keeper.ctx, keeper.svcCtx.EthClient, stablecoinCA.Hex(), ord.Account)
	if err != nil {
		logger.Errorf("[OrderKeeper] Êü•ËØ¢‰ª£Â∏Å‰ΩôÈ¢ùÂ§±Ë¥•, token: %s, %v", stablecoinCA, err)
		return
	}
	stablecoinBal := evm.ParseUnits(bal, keeper.svcCtx.Config.Chain.StablecoinDecimals)

	// Êõ¥Êñ∞ËÆ¢ÂçïÁä∂ÊÄÅ
	err = utils.Tx(keeper.ctx, keeper.svcCtx.DbClient, func(tx *ent.Tx) error {
		if ord.GridId != nil {
			switch ord.Type {
			case order.TypeBuy:
				err := model.NewGridModel(tx.Grid).SetBoughtStatus(
					keeper.ctx, *ord.GridId, finalPrice, outAmount)
				if err != nil {
					return err
				}
			case order.TypeSell:
				_, err := model.NewGridModel(tx.Grid).DeleteByGuid(keeper.ctx, *ord.GridId)
				if err != nil {
					return err
				}
			}
		}

		if !cost.IsZero() {
			profit := outAmount.Sub(cost)
			err = model.NewOrderModel(tx.Order).UpdateProfit(keeper.ctx, ord.ID, profit)
			if err != nil {
				return err
			}
		}

		err = model.NewOrderModel(tx.Order).SetOrderClosedStatus(keeper.ctx, ord.ID, finalPrice, outAmount)
		if err != nil {
			return err
		}

		if s != nil && ord.GridId != nil && s.FirstOrderId == nil {
			err = model.NewStrategyModel(tx.Strategy).UpdateFirstOrderId(keeper.ctx, s.ID, &ord.ID)
			if err != nil {
				return err
			}
		}

		return nil
	})

	if err != nil {
		logger.Errorf("[OrderKeeper] ËÆæÁΩÆËÆ¢Âçï closed Áä∂ÊÄÅÂ§±Ë¥•, id: %d, hash: %s, %v", ord.ID, ord.TxHash, err)
		return
	}
	logger.Infof("[OrderKeeper] ËÆæÁΩÆËÆ¢Âçï closed Áä∂ÊÄÅ, id: %d, type: %s, finalPrice: %s, outAmount: %s, hash: %s",
		ord.ID, ord.Type, finalPrice, outAmount, ord.TxHash)

	// ÂèëÈÄÅÁîµÊä•ÈÄöÁü•
	chainId := keeper.svcCtx.Config.Chain.Id
	switch ord.Type {
	case order.TypeBuy:
		usdChange := decimal.Zero
		v, ok := tokenBalanceChanges[stablecoinCA]
		if ok {
			usdChange = evm.ParseUnits(v, keeper.svcCtx.Config.Chain.StablecoinDecimals)
		}

		text := fmt.Sprintf("üü¢ ÁΩëÊ†º `#%d` ‰π∞ÂÖ• %sU [%s](%s) üí∞ ‰ΩôÈ¢ù: %sU [>>](%s)",
			*ord.GridNumber,
			usdChange.Abs().Truncate(2),
			ord.Symbol,
			utils.GetGmgnTokenLink(chainId, ord.Token),
			stablecoinBal.Truncate(2),
			utils.GetBlockExplorerTxLink(chainId, ord.TxHash),
		)
		keeper.sendNotification(ord, text, false)
	case order.TypeSell:
		if ord.GridId != nil {
			usdChange := decimal.Zero
			v, ok := tokenBalanceChanges[stablecoinCA]
			if ok {
				usdChange = evm.ParseUnits(v, keeper.svcCtx.Config.Chain.StablecoinDecimals)
			}

			text := fmt.Sprintf("üî¥ ÁΩëÊ†º `#%d` ÂçñÂá∫ %sU [%s](%s) üí∞ ‰ΩôÈ¢ù: %sU [>>](%s)",
				*ord.GridNumber,
				usdChange.Abs().Truncate(2),
				ord.Symbol,
				utils.GetGmgnTokenLink(chainId, ord.Token),
				stablecoinBal.Truncate(2),
				utils.GetBlockExplorerTxLink(chainId, ord.TxHash),
			)
			keeper.sendNotification(ord, text, false)
		} else {
			text := fmt.Sprintf("‚úÖ Ê∏Ö‰ªì *%s* ‰ª£Â∏ÅÊàêÂäü, Êàê‰∫§‰ª∑Ê†º: %s, üí∞ ÈáëÈ¢ù: %sU, üí∞ ‰ΩôÈ¢ù: %sU [>>](%s))",
				ord.Symbol, format.Price(finalPrice, 5), outAmount.Truncate(2), stablecoinBal.Truncate(2), utils.GetBlockExplorerTxLink(chainId, ord.TxHash))
			keeper.sendNotification(ord, text, true)
		}
	}
}

func (keeper *OrderKeeper) handleRejectOrder(ord *ent.Order, reason string) {
	err := utils.Tx(keeper.ctx, keeper.svcCtx.DbClient, func(tx *ent.Tx) error {
		if ord.GridId != nil {
			if ord.Type == order.TypeBuy {
				_, err := model.NewGridModel(tx.Grid).DeleteByGuid(keeper.ctx, *ord.GridId)
				if err != nil {
					return err
				}
			} else {
				err := model.NewGridModel(tx.Grid).UpdateStatusByGuid(keeper.ctx, *ord.GridId, grid.StatusBought)
				if err != nil {
					return err
				}
			}
		}

		return model.NewOrderModel(tx.Order).SetOrderRejectedStatus(keeper.ctx, ord.ID, reason)
	})
	if err != nil {
		logger.Errorf("[OrderKeeper] ËÆæÁΩÆËÆ¢Âçï rejected Áä∂ÊÄÅÂ§±Ë¥•, id: %d, hash: %s, %v", ord.ID, ord.TxHash, err)
		return
	}
	logger.Infof("[OrderKeeper] ËÆæÁΩÆËÆ¢Âçï rejected Áä∂ÊÄÅ, id: %d, hash: %s, reason: %s", ord.ID, ord.TxHash, reason)

	// ÂèëÈÄÅÂ§±Ë¥•ÈÄöÁü•
	chainId := keeper.svcCtx.Config.Chain.Id
	switch ord.Type {
	case order.TypeBuy:
		keeper.sendNotification(ord, fmt.Sprintf("‚ùå ÁΩëÊ†º `#%d` ‰π∞ÂÖ• %sU [%s](%s), ÂéüÂõ†: ÊµÅÂä®ÊÄß‰∏çË∂≥ÊàñËÄÖÊªëÁÇπÈóÆÈ¢ò [>>](%s)",
			*ord.GridNumber, ord.InAmount.Truncate(2), ord.Symbol, utils.GetGmgnTokenLink(chainId, ord.Token), utils.GetBlockExplorerTxLink(chainId, ord.TxHash)), false)
	case order.TypeSell:
		if ord.GridId != nil {
			keeper.sendNotification(ord, fmt.Sprintf("‚ùå ÁΩëÊ†º `#%d` ÂçñÂá∫ %s [%s](%s) Â§±Ë¥•, ÂéüÂõ†: ÊµÅÂä®ÊÄß‰∏çË∂≥ÊàñËÄÖÊªëÁÇπÈóÆÈ¢ò [>>](%s)",
				*ord.GridNumber, ord.InAmount, ord.Symbol, utils.GetGmgnTokenLink(chainId, ord.Token), utils.GetBlockExplorerTxLink(chainId, ord.TxHash)), false)
		} else {
			keeper.sendNotification(ord, fmt.Sprintf("‚ùå Ê∏Ö‰ªì *%s* ‰ª£Â∏ÅÂ§±Ë¥•, ÂéüÂõ†: ÊµÅÂä®ÊÄß‰∏çË∂≥ÊàñËÄÖÊªëÁÇπÈóÆÈ¢ò [>>](%s)", ord.Symbol, utils.GetBlockExplorerTxLink(chainId, ord.TxHash)), true)
		}
	}

	// ÈáçËØïÊ∏Ö‰ªìÊìç‰Ωú
	if ord.Type == order.TypeSell && ord.GridId == nil {
		keeper.handleRetryExit(ord)
	}
}

func (keeper *OrderKeeper) handlePolling() {
	// Ëé∑ÂèñËÆ¢ÂçïÂàóË°®
	orders, err := keeper.svcCtx.OrderModel.FindPendingOrders(keeper.ctx, 100)
	if err != nil {
		logger.Errorf("[OrderKeeper] Ëé∑ÂèñËÆ¢ÂçïÂàóË°®Â§±Ë¥•, %v", err)
	}
	if len(orders) == 0 {
		return
	}

	// Ê£ÄÊü•‰∫§ÊòìÁä∂ÊÄÅ
	now := time.Now()
	openOrders := make([]*ent.Order, 0)
	tokenBalanceChanges := make(map[int]map[common.Address]*big.Int)
	for _, item := range orders {
		// ÂøΩÁï•Ë∂ÖÊó∂‰∫§Êòì
		_, timeout := keeper.timeoutTxs[item.TxHash]
		if timeout {
			continue
		}

		// Êü•ËØ¢‰∫§ÊòìÊî∂ÊçÆ
		receipt, err := keeper.svcCtx.EthClient.TransactionReceipt(keeper.ctx, common.HexToHash(item.TxHash))
		if err != nil {
			// Ê†áËÆ∞Ë∂ÖÊó∂‰∫§Êòì
			if strings.Contains(err.Error(), "not found") {
				if now.Sub(item.CreateTime) > time.Minute*2 {
					keeper.timeoutTxs[item.TxHash] = struct{}{}
					logger.Errorf("[OrderKeeper] ‰∫§ÊòìÊâìÂåÖË∂ÖÊó∂, account: %s, nonce: %d, hash: %s, createTime: %v",
						item.Account, item.Nonce, item.TxHash, item.CreateTime)
				}
				continue
			}

			logger.Errorf("[OrderKeeper] Êü•ËØ¢‰∫§ÊòìÊî∂ÊçÆÂ§±Ë¥•, account: %s, nonce: %d, hash: %s, %v", item.Account, item.Nonce, item.TxHash, err)
			return
		}

		// Â§ÑÁêÜÈ©≥ÂõûËÆ¢Âçï
		if receipt.Status == 0 {
			keeper.handleRejectOrder(item, "execution reverted")
			continue
		}

		// Êü•ËØ¢‰ΩôÈ¢ùÂèòÂåñ
		changes, err := evm.GetTokenBalanceChanges(keeper.ctx, keeper.svcCtx.EthClient, receipt, item.Account)
		if err != nil {
			logger.Errorf("[OrderKeeper] Êü•ËØ¢‰ª£Â∏Å‰ΩôÈ¢ùÂèòÂåñÂ§±Ë¥•, account: %s, nonce: %d, hash: %s, %v", item.Account, item.Nonce, item.TxHash, err)
			return
		}

		openOrders = append(openOrders, item)
		tokenBalanceChanges[item.ID] = changes
	}

	if len(openOrders) == 0 {
		return
	}

	// Êõ¥Êñ∞ËÆ¢Âçï‰ø°ÊÅØ
	for _, item := range openOrders {
		changes, ok := tokenBalanceChanges[item.ID]
		if !ok {
			continue
		}
		keeper.handleCloseOrder(item, changes)
	}
}
